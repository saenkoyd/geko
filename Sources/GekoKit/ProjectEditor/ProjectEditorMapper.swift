import Foundation
import struct ProjectDescription.AbsolutePath
import GekoCore
import GekoGraph
import GekoLoader
import GekoSupport

protocol ProjectEditorMapping: AnyObject {
    func map(
        name: String,
        gekoPath: AbsolutePath,
        sourceRootPath: AbsolutePath,
        destinationDirectory: AbsolutePath,
        configPath: AbsolutePath?,
        dependenciesPath: AbsolutePath?,
        packageManifestPath: AbsolutePath?,
        projectManifests: [AbsolutePath],
        editablePluginManifests: [EditablePluginManifest],
        pluginProjectDescriptionHelpersModule: [ProjectDescriptionHelpersModule],
        helpers: [AbsolutePath],
        templateSources: [AbsolutePath],
        templateResources: [AbsolutePath],
        stencils: [AbsolutePath],
        projectDescriptionSearchPath: ProjectDescriptionSearchPaths
    ) throws -> Graph
}

// swiftlint:disable:next type_body_length
final class ProjectEditorMapper: ProjectEditorMapping {
    private let swiftPackageManagerController: SwiftPackageManagerControlling
    private let manifestFilesLocator: ManifestFilesLocating

    init(
        swiftPackageManagerController: SwiftPackageManagerControlling = SwiftPackageManagerController(),
        manifestFilesLocator: ManifestFilesLocating = ManifestFilesLocator()
    ) {
        self.swiftPackageManagerController = swiftPackageManagerController
        self.manifestFilesLocator = manifestFilesLocator
    }

    // swiftlint:disable:next function_body_length
    func map(
        name: String,
        gekoPath: AbsolutePath,
        sourceRootPath: AbsolutePath,
        destinationDirectory: AbsolutePath,
        configPath: AbsolutePath?,
        dependenciesPath: AbsolutePath?,
        packageManifestPath: AbsolutePath?,
        projectManifests: [AbsolutePath],
        editablePluginManifests: [EditablePluginManifest],
        pluginProjectDescriptionHelpersModule: [ProjectDescriptionHelpersModule],
        helpers: [AbsolutePath],
        templateSources: [AbsolutePath],
        templateResources: [AbsolutePath],
        stencils: [AbsolutePath],
        projectDescriptionSearchPath: ProjectDescriptionSearchPaths
    ) throws -> Graph {
        let swiftVersion = try System.shared.swiftVersion()

        let localEditablePluginManifests = editablePluginManifests.filter { $0.location == .local }
        let localPluginsProject = mapPluginsProject(
            projectName: "LocalPlugins",
            pluginManifests: localEditablePluginManifests,
            projectDescriptionPath: projectDescriptionSearchPath,
            swiftVersion: swiftVersion,
            sourceRootPath: sourceRootPath,
            destinationDirectory: destinationDirectory,
            gekoPath: gekoPath
        )
        
        let remoteEditablesPluginManifests = editablePluginManifests.filter { $0.location == .remote }
        let remotePluginsProject = mapPluginsProject(
            projectName: "RemotePlugins",
            pluginManifests: remoteEditablesPluginManifests,
            projectDescriptionPath: projectDescriptionSearchPath,
            swiftVersion: swiftVersion,
            sourceRootPath: sourceRootPath,
            destinationDirectory: destinationDirectory,
            gekoPath: gekoPath
        )

        let manifestsProject = try mapManifestsProject(
            projectManifests: projectManifests,
            projectDescriptionPath: projectDescriptionSearchPath,
            swiftVersion: swiftVersion,
            sourceRootPath: sourceRootPath,
            destinationDirectory: destinationDirectory,
            gekoPath: gekoPath,
            helpers: helpers,
            templateSources: templateSources,
            templateResources: templateResources,
            stencils: stencils,
            configPath: configPath,
            dependenciesPath: dependenciesPath,
            packageManifestPath: packageManifestPath,
            editablePluginTargets: editablePluginManifests.map(\.name),
            pluginProjectDescriptionHelpersModule: pluginProjectDescriptionHelpersModule
        )

        let projects = [localPluginsProject, remotePluginsProject, manifestsProject].compactMap { $0 }

        let workspace = Workspace(
            path: sourceRootPath,
            xcWorkspacePath: destinationDirectory.appending(component: "\(name).xcworkspace"),
            name: name,
            projects: projects.map(\.path),
            generationOptions: .init(
                enableAutomaticXcodeSchemes: false,
                autogeneratedWorkspaceSchemes: .enabled(codeCoverageMode: .disabled, testingOptions: []),
                lastXcodeUpgradeCheck: nil,
                renderMarkdownReadme: false,
                autogenerateLocalPodsProjects: .disabled,
                autogenerateLocalPodsSchemes: .disabled,
                commonSettings: [],
                configurations: ["Debug": .debug, "Release": .release]
            )
        )

        let graphProjects = Dictionary(uniqueKeysWithValues: projects.map { ($0.path, $0) })

        let graphTargets = projects
            .lazy
            .map { ($0.path, $0.targets) }
            .map { path, targets in (path, Dictionary(uniqueKeysWithValues: targets.map { ($0.name, $0) })) }

        let graphDependencies = projects
            .lazy
            .flatMap { project -> [(GraphDependency, Set<GraphDependency>)] in
                let graphDependencies = project.targets.map(\.dependencies).lazy.map { dependencies in
                    dependencies.lazy.compactMap { dependency -> GraphDependency? in
                        switch dependency {
                        case let .target(name, _, _):
                            if let localPluginsProject, localEditablePluginManifests.contains(where: { $0.name == name }) {
                                return .target(name: name, path: localPluginsProject.path)
                            } else if let remotePluginsProject, remoteEditablesPluginManifests.contains(where: { $0.name == name }) {
                                return .target(name: name, path: remotePluginsProject.path)
                            } else {
                                return .target(name: name, path: project.path)
                            }
                        default:
                            return nil
                        }
                    }
                }

                return zip(project.targets, graphDependencies).map { target, dependencies in
                    (GraphDependency.target(name: target.name, path: project.path), Set(dependencies))
                }
            }

        return Graph(
            name: name,
            path: sourceRootPath,
            workspace: workspace,
            projects: graphProjects,
            targets: Dictionary(uniqueKeysWithValues: graphTargets),
            dependencies: Dictionary(uniqueKeysWithValues: graphDependencies),
            ignoredDependencies: [:],
            frameworks: [:],
            libraries: [:],
            xcframeworks: [:],
            dependencyConditions: [:],
            externalDependenciesGraph: .none
        )
    }

    // swiftlint:disable:next function_body_length
    private func mapManifestsProject(
        projectManifests: [AbsolutePath],
        projectDescriptionPath: ProjectDescriptionSearchPaths,
        swiftVersion: String,
        sourceRootPath: AbsolutePath,
        destinationDirectory: AbsolutePath,
        gekoPath: AbsolutePath,
        helpers: [AbsolutePath],
        templateSources: [AbsolutePath],
        templateResources: [AbsolutePath],
        stencils: [AbsolutePath],
        configPath: AbsolutePath?,
        dependenciesPath: AbsolutePath?,
        packageManifestPath: AbsolutePath?,
        editablePluginTargets: [String],
        pluginProjectDescriptionHelpersModule: [ProjectDescriptionHelpersModule]
    ) throws -> Project? {
        guard !projectManifests.isEmpty else { return nil }

        let projectName = "Manifests"
        let projectPath = sourceRootPath.appending(component: projectName)
        let manifestsFilesGroup = ProjectGroup.group(name: projectName)
        let baseTargetSettings = Settings(
            base: targetBaseSettings(
                projectDescriptionPath: projectDescriptionPath,
                pluginHelperLibraryPaths: [],
                swiftVersion: swiftVersion
            ),
            configurations: Settings.default.configurations,
            defaultSettings: .recommended
        )

        let configTarget: Target? = {
            guard let configPath else { return nil }
            return editorHelperTarget(
                name: "Config",
                filesGroup: manifestsFilesGroup,
                targetSettings: baseTargetSettings,
                sourcePaths: [configPath]
            )
        }()

        let editablePluginTargetDependencies = editablePluginTargets.map { TargetDependency.target(name: $0) }
        let targetWithLinkedPluginsSettings = Settings(
            base: targetBaseSettings(
                projectDescriptionPath: projectDescriptionPath,
                pluginHelperLibraryPaths: pluginProjectDescriptionHelpersModule.map(\.path),
                swiftVersion: swiftVersion
            ),
            configurations: Settings.default.configurations,
            defaultSettings: .recommended
        )

        let helpersTarget: Target? = {
            guard !helpers.isEmpty else { return nil }
            return editorHelperTarget(
                name: Constants.helpersDirectoryName,
                filesGroup: manifestsFilesGroup,
                targetSettings: targetWithLinkedPluginsSettings,
                sourcePaths: helpers,
                dependencies: editablePluginTargetDependencies
            )
        }()

        let templatesTarget: Target? = {
            let generateTemplateTarget = !templateSources.isEmpty || !templateResources.isEmpty
            guard generateTemplateTarget else { return nil }
            return editorHelperTarget(
                name: Constants.templatesDirectoryName,
                filesGroup: manifestsFilesGroup,
                targetSettings: baseTargetSettings,
                sourcePaths: templateSources,
                additionalFilePaths: templateResources,
                dependencies: helpersTarget.flatMap { [TargetDependency.target(name: $0.name)] } ?? []
            )
        }()

        let stencilsTarget: Target? = {
            guard !stencils.isEmpty else { return nil }
            return editorHelperTarget(
                name: Constants.stencilsDirectoryName,
                filesGroup: manifestsFilesGroup,
                targetSettings: baseTargetSettings,
                sourcePaths: stencils,
                dependencies: helpersTarget.flatMap { [TargetDependency.target(name: $0.name)] } ?? []
            )
        }()

        let helperTargetDependencies = helpersTarget.map { [TargetDependency.target(name: $0.name)] } ?? []
        let helperAndPluginDependencies = helperTargetDependencies + editablePluginTargetDependencies

        let dependenciesTarget: Target? = {
            guard let dependenciesPath else { return nil }
            let dependenciesExtensions = try? manifestFilesLocator.locateManifestExtensionFiles(for: Manifest.dependencies, at: dependenciesPath)
            return editorHelperTarget(
                name: "Dependencies",
                filesGroup: manifestsFilesGroup,
                targetSettings: targetWithLinkedPluginsSettings,
                sourcePaths: [dependenciesPath] + (dependenciesExtensions ?? []),
                dependencies: helperAndPluginDependencies
            )
        }()

        let packagesTarget: Target? = try {
            guard let packageManifestPath,
                let xcode = try XcodeController.shared.selected()
            else { return nil }
            let packageVersion = try swiftPackageManagerController.getToolsVersion(at: packageManifestPath.parentDirectory)

            var packagesSettings = targetBaseSettings(
                projectDescriptionPath: projectDescriptionPath,
                pluginHelperLibraryPaths: pluginProjectDescriptionHelpersModule.map(\.path),
                swiftVersion: swiftVersion
            )
            packagesSettings.merge(
                [
                    "OTHER_SWIFT_FLAGS": .array([
                        "-package-description-version",
                        packageVersion.description,
                        "-D", "GEKO",
                    ]),
                    "SWIFT_INCLUDE_PATHS": .array([
                        "\(xcode.path.pathString)/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift/pm/ManifestAPI"
                    ]),
                ],
                uniquingKeysWith: { $1 }
            )

            let dependencies: [TargetDependency] =
                helpersTarget == nil
                ? []
                : [
                    .target(name: "ProjectDescriptionHelpers")
                ]

            return editorHelperTarget(
                name: "Packages",
                filesGroup: manifestsFilesGroup,
                targetSettings: Settings(
                    base: packagesSettings,
                    configurations: Settings.default.configurations,
                    defaultSettings: .recommended
                ),
                sourcePaths: [packageManifestPath],
                dependencies: dependencies
            )
        }()

        let manifestsTargets = namedManifests(projectManifests).map { name, projectManifestSourcePath -> Target in
            var sourcePaths = [projectManifestSourcePath]
            if let manifest = Manifest.from(path: projectManifestSourcePath) {
                sourcePaths +=
                    (try? manifestFilesLocator.locateManifestExtensionFiles(
                        for: manifest,
                        at: projectManifestSourcePath
                    )) ?? []
            }

            return editorHelperTarget(
                name: name,
                filesGroup: manifestsFilesGroup,
                targetSettings: targetWithLinkedPluginsSettings,
                sourcePaths: sourcePaths,
                dependencies: helperAndPluginDependencies
            )
        }

        let targets =
            [
                helpersTarget,
                templatesTarget,
                stencilsTarget,
                configTarget,
                dependenciesTarget,
                packagesTarget,
            ]
            .compactMap { $0 }
            + manifestsTargets

        let buildAction = BuildAction(targets: targets.map { TargetReference(projectPath: projectPath, name: $0.name) })
        let arguments = Arguments(launchArguments: [LaunchArgument(name: "generate --path \(sourceRootPath)", isEnabled: true)])
        let runAction = RunAction(
            configuration: .configuration("Debug"),
            attachDebugger: true,
            customLLDBInitFile: nil,
            executable: nil,
            filePath: gekoPath,
            arguments: arguments,
            diagnosticsOptions: .init()
        )
        let scheme = Scheme(name: projectName, shared: true, buildAction: buildAction, runAction: runAction)
        let projectSettings = Settings(
            base: [:],
            configurations: Settings.default.configurations,
            defaultSettings: .recommended
        )

        return Project(
            path: projectPath,
            sourceRootPath: sourceRootPath,
            xcodeProjPath: destinationDirectory.appending(component: "\(projectName).xcodeproj"),
            name: projectName,
            organizationName: nil,
            options: .init(
                automaticSchemesOptions: .disabled,
                defaultKnownRegions: nil,
                developmentRegion: nil,
                disableBundleAccessors: true,
                disableShowEnvironmentVarsInScriptPhases: false,
                textSettings: .init(usesTabs: nil, indentWidth: nil, tabWidth: nil, wrapsLines: nil),
                xcodeProjectName: nil
            ),
            settings: projectSettings,
            filesGroup: manifestsFilesGroup,
            targets: targets,
            schemes: [scheme],
            ideTemplateMacros: nil,
            additionalFiles: [],
            lastUpgradeCheck: nil,
            isExternal: false,
            projectType: .geko
        )
    }

    // swiftlint:disable:next function_body_length
    private func mapPluginsProject(
        projectName: String,
        pluginManifests: [EditablePluginManifest],
        projectDescriptionPath: ProjectDescriptionSearchPaths,
        swiftVersion: String,
        sourceRootPath: AbsolutePath,
        destinationDirectory: AbsolutePath,
        gekoPath _: AbsolutePath
    ) -> Project? {
        guard !pluginManifests.isEmpty else { return nil }

        let projectPath = sourceRootPath.appending(component: projectName)
        let pluginsFilesGroup = ProjectGroup.group(name: projectName)
        let targetSettings = Settings(
            base: targetBaseSettings(
                projectDescriptionPath: projectDescriptionPath,
                pluginHelperLibraryPaths: [],
                swiftVersion: swiftVersion
            ),
            configurations: Settings.default.configurations,
            defaultSettings: .recommended
        )

        let pluginTargets = pluginManifests.map { manifest -> Target in
            let pluginManifest = manifest.path.appending(component: "Plugin.swift")
            let pluginHelpersPath = manifest.path.appending(component: Constants.helpersDirectoryName)
            let pluginTemplatesPath = manifest.path.appending(component: Constants.templatesDirectoryName)
            let sourcePaths =
                [pluginManifest] + FileHandler.shared.glob(pluginHelpersPath, glob: "**/*.swift") + FileHandler.shared.glob(pluginTemplatesPath, glob: "**/*.swift")
                + FileHandler.shared.glob(pluginTemplatesPath, glob: "**/*.stencil")
            return editorHelperTarget(
                name: manifest.name,
                filesGroup: pluginTargetProjectGroup(manifest: manifest, pluginsFilesGroup: pluginsFilesGroup),
                targetSettings: targetSettings,
                sourcePaths: sourcePaths,
                dependencies: []
            )
        }

        let schemes = pluginTargets.map { target -> Scheme in
            let buildAction = BuildAction(targets: [TargetReference(projectPath: projectPath, name: target.name)])
            return Scheme(name: target.name, shared: true, buildAction: buildAction, runAction: nil)
        }

        let allPluginsScheme = Scheme(
            name: projectName,
            shared: true,
            buildAction: BuildAction(targets: pluginTargets.map { TargetReference(projectPath: projectPath, name: $0.name) }),
            runAction: nil
        )

        let allSchemes = schemes + [allPluginsScheme]

        let projectSettings = Settings(
            base: [:],
            configurations: Settings.default.configurations,
            defaultSettings: .recommended
        )

        return Project(
            path: projectPath,
            sourceRootPath: sourceRootPath,
            xcodeProjPath: destinationDirectory.appending(component: "\(projectName).xcodeproj"),
            name: projectName,
            organizationName: nil,
            options: .init(
                automaticSchemesOptions: .disabled,
                defaultKnownRegions: nil,
                developmentRegion: nil,
                disableBundleAccessors: true,
                disableShowEnvironmentVarsInScriptPhases: false,
                textSettings: .init(usesTabs: nil, indentWidth: nil, tabWidth: nil, wrapsLines: nil),
                xcodeProjectName: nil
            ),
            settings: projectSettings,
            filesGroup: pluginsFilesGroup,
            targets: pluginTargets,
            schemes: allSchemes,
            ideTemplateMacros: nil,
            additionalFiles: [],
            lastUpgradeCheck: nil,
            isExternal: false,
            projectType: .geko
        )
    }
    
    private func pluginTargetProjectGroup(manifest: EditablePluginManifest, pluginsFilesGroup: ProjectGroup) -> ProjectGroup {
        switch manifest.location {
        case .local:
            pluginsFilesGroup
        case .remote:
            .groupReference(name: manifest.name, path: manifest.path)
        }
    }

    /// Collects all targets into a dictionary where each key is a reference to a target
    /// which maps to a set of target references representing the target's dependencies.
    /// - Parameters:
    ///   - targets: The targets to map to their dependencies.
    ///   - projectPath: The path to the project where the targets are defined.
    /// - Returns: dictionary where each key is a reference to a target and value is the target's dependencies.
    private func mapTargetsToDependencies(
        targets: [Target],
        projectPath: AbsolutePath
    ) -> [TargetReference: Set<TargetReference>] {
        targets.reduce(into: [TargetReference: Set<TargetReference>]()) { result, target in
            let dependencyRefs = target.dependencies.lazy.compactMap { dependency -> TargetReference? in
                switch dependency {
                case let .target(name, _, _):
                    return TargetReference(projectPath: projectPath, name: name)
                default:
                    return nil
                }
            }
            result[TargetReference(projectPath: projectPath, name: target.name)] = Set(dependencyRefs)
        }
    }

    /// It returns a dictionary with unique name as key for each Manifest file
    /// - Parameter manifests: Manifest files to assign an unique name
    /// - Returns: Dictionary composed by unique name as key and Manifest file as value.
    private func namedManifests(_ manifests: [AbsolutePath]) -> [String: AbsolutePath] {
        manifests.reduce(into: [String: AbsolutePath]()) { result, manifest in
            var name = "\(manifest.parentDirectory.basename)Manifests"
            while result[name] != nil {
                name = "_\(name)"
            }
            result[name] = manifest
        }
    }

    /// It returns a target for edit project.
    /// - Parameters:
    ///   - name: Name for the target.
    ///   - filesGroup: File group for target.
    ///   - targetSettings: Target's settings.
    ///   - sourcePaths: Target's sources.
    ///   - dependencies: Target's dependencies.
    /// - Returns: Target for edit project.
    private func editorHelperTarget(
        name: String,
        filesGroup: ProjectGroup,
        targetSettings: Settings,
        sourcePaths: [AbsolutePath],
        additionalFilePaths: [AbsolutePath] = [],
        dependencies: [TargetDependency] = []
    ) -> Target {
        Target(
            name: name,
            destinations: .macOS,
            product: .staticFramework,
            productName: name,
            bundleId: "io.geko.${PRODUCT_NAME:rfc1034identifier}",
            sources: [SourceFiles(paths: sourcePaths)],
            dependencies: dependencies,
            settings: targetSettings,
            additionalFiles: additionalFilePaths.map { .file(path: $0) },
            filesGroup: filesGroup
        )
    }

    /// Returns a ``SettingsDictionary`` which includes the base settings for a target.
    /// Base settings include things such as: the search paths for the given `includes` and the Swift version.
    private func targetBaseSettings(
        projectDescriptionPath: ProjectDescriptionSearchPaths,
        pluginHelperLibraryPaths: [AbsolutePath],
        swiftVersion: String
    ) -> SettingsDictionary {
        // In development, the .swiftmodule is generated in a directory up from the directory of the framework.
        // /path/to/derived/geko-xyz/
        //    PackageFrameworks/
        //      ProjectDescription.framework
        //    ProjectDescription.swiftmodule
        // Because of that we need to expose the parent directory too in SWIFT_INCLUDE_PATHS
        let projectFrameworkSearchPaths = [projectDescriptionPath.frameworkSearchPath]
        let projectLibrarySearchPaths = [projectDescriptionPath.librarySearchPath]
        let projectIncludeSearchPaths = [projectDescriptionPath.includeSearchPath]

        let pluginHelperSearchPaths = pluginHelperLibraryPaths.map(\.parentDirectory)

        let frameworkPaths = (projectFrameworkSearchPaths + pluginHelperSearchPaths).map { "\"\($0)\"" }
        let libraryPaths = (projectLibrarySearchPaths + pluginHelperSearchPaths).map { "\"\($0)\"" }
        let includePaths = (projectIncludeSearchPaths + pluginHelperSearchPaths).map { "\"\($0)\"" }
        return [
            "FRAMEWORK_SEARCH_PATHS": .array(frameworkPaths),
            "LIBRARY_SEARCH_PATHS": .array(libraryPaths),
            "SWIFT_INCLUDE_PATHS": .array(includePaths),
            "SWIFT_VERSION": .string(swiftVersion),
        ]
    }
}
