import Foundation
import GekoCore
import GekoGraph
import GekoSupport
import ProjectDescription

extension Workspace.GenerationOptions {
    /// Maps ProjectDescription.Workspace.GenerationOptions instance into a GekoGraph.Workspace.GenerationOptions model.
    /// - Parameters:
    ///   - generatorPaths: Generator paths.
    mutating func resolvePaths(generatorPaths: GeneratorPaths) throws {
        try autogeneratedWorkspaceSchemes.resolvePaths(generatorPaths: generatorPaths)

        try autogenerateLocalPodsSchemes.resolvePaths(generatorPaths: generatorPaths)

        try autogenerateLocalPodsProjects.resolvePaths(generatorPaths: generatorPaths)
    }

    mutating func resolveGlobs() throws {
        try autogenerateLocalPodsSchemes.resolveGlobs()
        try autogenerateLocalPodsProjects.resolveGlobs()
    }
}

extension Workspace.GenerationOptions.AutogeneratedWorkspaceSchemes {
    mutating func resolvePaths(generatorPaths: GeneratorPaths) throws {
        switch self {
        case .disabled:
            break
        case .enabled(var codeCoverageMode, let testingOptions, let testLanguage, let testRegion, let testScreenCaptureFormat):
            try codeCoverageMode.resolvePaths(generatorPaths: generatorPaths)

            self = .enabled(
                codeCoverageMode: codeCoverageMode,
                testingOptions: testingOptions,
                testLanguage: testLanguage,
                testRegion: testRegion,
                testScreenCaptureFormat: testScreenCaptureFormat
            )
        }
    }
}

extension Workspace.GenerationOptions.AutogeneratedWorkspaceSchemes.CodeCoverageMode {
    mutating func resolvePaths(generatorPaths: GeneratorPaths) throws {
        switch self {
        case .all:
            break
        case .relevant:
            break
        case var .targets(targets):
            for i in 0 ..< targets.count {
                try targets[i].resolvePaths(generatorPaths: generatorPaths)
            }
            self = .targets(targets)
        case .disabled:
            break
        }
    }
}

extension Workspace.GenerationOptions.AutogenerateLocalPodsProjects {
    mutating func resolvePaths(generatorPaths: GeneratorPaths) throws {
        switch self {
        case .disabled: 
            break
        case .automatic(var paths, let base):
            for i in 0 ..< paths.count {
                paths[i] = try generatorPaths.resolve(path: paths[i])
            }
            let absoluteBase = try base.map { try generatorPaths.resolve(path: $0) }
            self = .automatic(paths, absoluteBase)
        case let .manual(paths):
            let absolutePaths = Dictionary(
                uniqueKeysWithValues: try paths.map {
                    (
                        try generatorPaths.resolve(path: $0.key),
                        try generatorPaths.resolve(path: $0.value)
                    )
                }
            )
            self = .manual(absolutePaths)
        }
    }

    mutating func resolveGlobs() throws {
        func globPodspecs(_ path: FilePath) throws -> [AbsolutePath] {
            let podspecs = try FileHandler.shared.glob(AbsolutePath.root, glob: String(path.pathString.dropFirst()))
                .lazy
                .filter {
                    $0.pathString.contains(".podspec")
                }
                .map { try FileHandler.shared.resolveSymlinks($0) }

            if podspecs.isEmpty {
                logger.warning("No podspecs found at: \(path.pathString)")
            }

            return Array(podspecs)
        }

        switch self {
        case .disabled: 
            break
        case .automatic(let paths, let base):
            let resolvedPaths = try paths.flatMap { try globPodspecs($0) }
            self = .automatic(resolvedPaths, base)
        case .manual:
            break
        }
    }
}

extension Workspace.GenerationOptions.AutogenerateLocalPodsSchemes {
    mutating func resolvePaths(generatorPaths: GeneratorPaths) throws {

        switch self {
        case .disabled:
            break
        case var .enabled(testPlans: testPlans):
            for i in 0 ..< testPlans.count {
                testPlans[i] = try generatorPaths.resolve(path: testPlans[i])
            }
            self = .enabled(testPlans: testPlans)
        }
    }

    mutating func resolveGlobs() throws {
        func globXCTestPlan(_ path: AbsolutePath) throws -> [AbsolutePath] {
            let xctestplans = FileHandler.shared.glob(AbsolutePath.root, glob: String(path.pathString.dropFirst()))
                .lazy
                .filter {
                    $0.pathString.contains(".xctestplan")
                }

            if xctestplans.isEmpty {
                logger.warning("No xctestplans found at: \(path.pathString)")
            }

            return Array(xctestplans)
        }

        switch self {
        case .disabled:
            break
        case let .enabled(testPlans: testPlans):
            var resolvedTestPlans: [AbsolutePath] = []

            for i in 0 ..< testPlans.count {
                let resolved = try globXCTestPlan(testPlans[i])
                resolvedTestPlans.append(contentsOf: resolved)
            }

            self = .enabled(testPlans: resolvedTestPlans)
        }
    }
}
