import Foundation
import GekoSupport
import XCTest

import struct ProjectDescription.AbsolutePath

@testable import GekoKit
@testable import GekoLoader
@testable import GekoSupportTesting

final class DumpServiceTests: GekoTestCase {
    private var subject: DumpService!

    override func setUp() {
        super.setUp()
        subject = DumpService()
    }

    override func tearDown() {
        subject = nil
        super.tearDown()
    }

    func test_prints_the_manifest_when_project_manifest() async throws {
        let tmpDir = try temporaryPath()
        let config = """
            import ProjectDescription

            let project = Project(
                name: "geko",
                organizationName: "geko",
                settings: Settings(
                    configurations: [:],
                    defaultSettings: .none
                ),
                targets: []
            )
            """
        try config.write(
            toFile: tmpDir.appending(component: "Project.swift").pathString,
            atomically: true,
            encoding: .utf8
        )
        try await subject.run(path: tmpDir.pathString, manifest: .project, resultFile: nil)
        let expectedStart = """
            {
              "additionalFiles": [

              ],
              "filesGroup": {
                "group": {
                  "name": "Project"
                }
              },
              "isExternal": false,
              "name": "geko",
              "options": {
                "automaticSchemesOptions": {
                  "enabled": {
                    "codeCoverageEnabled": false,
                    "targetSchemesGrouping": {
                      "byNameSuffix": {
                        "build": [
            """
        // middle part is ignored as order of suffixes is not predictable
        let expectedEnd = """
                        ]
                      }
                    },
                    "testPlans": [

                    ],
                    "testingOptions": 0
                  }
                },
                "disableBundleAccessors": true,
                "disableShowEnvironmentVarsInScriptPhases": true,
                "textSettings": {

                }
              },
              "organizationName": "geko",
              "path": "/",
              "projectType": {
                "geko": {
            
                }
              },
              "schemes": [

              ],
              "settings": {
                "base": {

                },
                "baseDebug": {

                },
                "configurations": [

                ],
                "defaultSettings": {
                  "none": {

                  }
                }
              },
              "sourceRootPath": "/",
              "targets": [

              ],
              "xcodeProjPath": "/"
            }
            """

        XCTAssertPrinterOutputContains(expectedStart)
        XCTAssertPrinterOutputContains(expectedEnd)
    }

    func test_prints_the_manifest_when_workspace_manifest() async throws {
        let tmpDir = try temporaryPath()
        let config = """
            import ProjectDescription

            let workspace = Workspace(
                name: "geko",
                projects: [],
                schemes: [],
                fileHeaderTemplate: nil,
                additionalFiles: []
            )
            """
        try config.write(
            toFile: tmpDir.appending(component: "Workspace.swift").pathString,
            atomically: true,
            encoding: .utf8
        )
        try await subject.run(path: tmpDir.pathString, manifest: .workspace, resultFile: nil)
        let expected = """
            {
              "additionalFiles": [

              ],
              "generationOptions": {
                "autogenerateLocalPodsProjects": {
                  "disabled": {

                  }
                },
                "autogenerateLocalPodsSchemes": {
                  "disabled": {

                  }
                },
                "autogeneratedWorkspaceSchemes": {
                  "enabled": {
                    "codeCoverageMode": {
                      "disabled": {

                      }
                    },
                    "testingOptions": 0
                  }
                },
                "commonSettings": [

                ],
                "configurations": {
                  "Debug": "debug",
                  "Release": "release"
                },
                "enableAutomaticXcodeSchemes": false,
                "renderMarkdownReadme": false
              },
              "name": "geko",
              "path": "@/.",
              "projects": [

              ],
              "schemes": [

              ],
              "workspaceMappers": [

              ],
              "xcWorkspacePath": "@/."
            }
            """

        XCTAssertPrinterOutputContains(expected)
    }

    func test_prints_the_manifest_when_config_manifest() async throws {
        let tmpDir = try temporaryPath()
        let config = """
            import ProjectDescription

            let config = Config(
                compatibleXcodeVersions: .all,
                cloud: nil,
                cache: nil,
                swiftVersion: nil,
                plugins: [],
                generationOptions: .options()
            )
            """
        try fileHandler.createFolder(tmpDir.appending(component: "Geko"))
        try config.write(
            toFile: tmpDir.appending(components: "Geko", "Config.swift").pathString,
            atomically: true,
            encoding: .utf8
        )
        try await subject.run(path: tmpDir.pathString, manifest: .config, resultFile: nil)
        let expected = """
            {
              "cocoapodsUseBundler": false,
              "compatibleXcodeVersions": {
                "all": {

                }
              },
              "generationOptions": {
                "addAstPathsToLinker": {
                  "disabled": {

                  }
                },
                "convertPathsInPodspecsToBuildableFolders": false,
                "disablePackageVersionLocking": false,
                "enforceExplicitDependencies": false,
                "resolveDependenciesWithSystemScm": false,
                "staticSideEffectsWarningTargets": {
                  "all": {

                  }
                }
              },
              "installOptions": {
                "passthroughSwiftPackageManagerArguments": [

                ]
              },
              "plugins": [

              ],
              "postGenerateScripts": [

              ],
              "preFetchScripts": [

              ],
              "preGenerateScripts": [

              ]
            }

            """

        XCTAssertPrinterOutputContains(expected)
    }

    func test_prints_the_manifest_when_template_manifest() async throws {
        let tmpDir = try temporaryPath()
        let config = """
            import ProjectDescription

            let template = Template(
                description: "geko",
                attributes: [],
                items: []
            )
            """
        try config.write(
            toFile: tmpDir.appending(component: "\(tmpDir.basenameWithoutExt).swift").pathString,
            atomically: true,
            encoding: .utf8
        )
        try await subject.run(path: tmpDir.pathString, manifest: .template, resultFile: nil)
        let expected = """
            {
              "attributes": [

              ],
              "description": "geko",
              "items": [

              ]
            }

            """

        XCTAssertPrinterOutputContains(expected)
    }

    func test_prints_the_manifest_when_plugin_manifest() async throws {
        let tmpDir = try temporaryPath()
        let config = """
            import ProjectDescription

            let plugin = Plugin(
                name: "geko"
            )
            """
        try config.write(
            toFile: tmpDir.appending(component: "Plugin.swift").pathString,
            atomically: true,
            encoding: .utf8
        )
        try await subject.run(path: tmpDir.pathString, manifest: .plugin, resultFile: nil)
        let expected = """
            {
              "executables": [

              ],
              "name": "geko"
            }

            """

        XCTAssertPrinterOutputContains(expected)
    }

    func test_prints_the_manifest_when_dependencies_manifest() async throws {
        let tmpDir = try temporaryPath()
        let config = """
            import ProjectDescription

            let dependencies = Dependencies(
                cocoapods: nil
            )
            """
        try fileHandler.createFolder(tmpDir.appending(component: "Geko"))
        try config.write(
            toFile: tmpDir.appending(components: "Geko", "Dependencies.swift").pathString,
            atomically: true,
            encoding: .utf8
        )
        try await subject.run(path: tmpDir.pathString, manifest: .dependencies, resultFile: nil)
        let expected = """
            {
            
            }

            """

        XCTAssertPrinterOutputContains(expected)
    }

    func test_run_throws_when_project_and_file_doesnt_exist() async throws {
        try await assertLoadingRaisesWhenManifestNotFound(manifest: .project)
    }

    func test_run_throws_when_workspace_and_file_doesnt_exist() async throws {
        try await assertLoadingRaisesWhenManifestNotFound(manifest: .workspace)
    }

    func test_run_throws_when_config_and_file_doesnt_exist() async throws {
        try await assertLoadingRaisesWhenManifestNotFound(manifest: .config)
    }

    func test_run_throws_when_template_and_file_doesnt_exist() async throws {
        try await assertLoadingRaisesWhenManifestNotFound(manifest: .template)
    }

    func test_run_throws_when_dependencies_and_file_doesnt_exist() async throws {
        try await assertLoadingRaisesWhenManifestNotFound(manifest: .dependencies)
    }

    func test_run_throws_when_plugin_and_file_doesnt_exist() async throws {
        try await assertLoadingRaisesWhenManifestNotFound(manifest: .plugin)
    }

    func test_run_throws_when_the_manifest_loading_fails() async throws {
        for manifest in DumpableManifest.allCases {
            let tmpDir = try temporaryPath()
            try "invalid config".write(
                toFile: tmpDir.appending(component: manifest.manifest.fileName(tmpDir)).pathString,
                atomically: true,
                encoding: .utf8
            )
            do {
                try await subject.run(path: tmpDir.pathString, manifest: manifest, resultFile: nil)
                XCTFail("Expected error not thrown")
            } catch {
                // can't use XCTAssertError because it doesn't support async
            }
        }
    }

    // MARK: - Helpers

    private func assertLoadingRaisesWhenManifestNotFound(manifest: DumpableManifest) async throws {
        try await fileHandler.inTemporaryDirectory { tmpDir in
            var expectedDirectory = tmpDir
            if manifest == .config || manifest == .dependencies {
                expectedDirectory = expectedDirectory.appending(component: Constants.gekoDirectoryName)
                if !self.fileHandler.exists(expectedDirectory) {
                    try self.fileHandler.createFolder(expectedDirectory)
                }
            }
            await self.XCTAssertThrowsSpecific(
                try await self.subject.run(path: tmpDir.pathString, manifest: manifest, resultFile: nil),
                ManifestLoaderError.manifestNotFound(manifest.manifest, expectedDirectory)
            )
        }
    }
}

extension DumpableManifest {
    var manifest: Manifest {
        switch self {
        case .project:
            return .project
        case .workspace:
            return .workspace
        case .config:
            return .config
        case .template:
            return .template
        case .dependencies:
            return .dependencies
        case .plugin:
            return .plugin
        }
    }
}
